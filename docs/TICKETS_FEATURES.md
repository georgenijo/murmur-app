# Local Dictation — Feature Tickets

---

## Status Summary

| Ticket | Description | Priority | Status |
|--------|-------------|----------|--------|
| FEAT-007 | Perceived Latency Reduction (token streaming + beam tuning) | P1 | TODO |
| FEAT-008 | OTA Auto-Updater (Tauri updater plugin) | P2 | TODO |
| FEAT-009 | Homebrew Tap distribution | P3 | TODO |
| FEAT-010 | curl one-line installer with model setup | P3 | TODO |
| FEAT-011 | Custom vocabulary / initial prompt for Whisper | P1 | TODO |

---

## FEAT-007: Perceived Latency Reduction — Token Streaming + Beam Tuning

**Priority:** P1
**Type:** Rust + Frontend
**Branch:** `feat/latency-reduction`
**Depends on:** —

### Context

The app currently waits for full whisper inference to complete before displaying or pasting any text. With large-v3-turbo on Metal, this means 1.5–3s of a blank/spinner screen after stopping recording. Two complementary changes close this gap:

1. **Beam size reduction** — drop from the whisper default (5) to 2. Saves ~20–30% inference time with negligible quality impact for clear dictation speech.
2. **Token streaming via segment callbacks** — whisper.cpp fires `new_segment_callback` as each segment is decoded. Wiring this through to the frontend means text appears progressively in the app UI while inference is still running, eliminating the "dead time" feeling entirely.

The paste still happens once at the end (full final text). Streaming is display-only — it does not affect injection behavior.

### Acceptance Criteria

- [ ] `beam_size` reduced to 2 in whisper inference params (`transcriber.rs`)
- [ ] `new_segment_callback` wired up in `transcriber.rs` to emit partial text as segments complete
- [ ] Partial segments surfaced to the frontend via a Tauri event (e.g. `transcription://partial`)
- [ ] App UI displays partial text live during inference — appending segments as they arrive
- [ ] Final paste behavior unchanged — full text pasted at end, not partial segments
- [ ] Partial text cleared/replaced cleanly when final result arrives
- [ ] No regression on transcription quality for clear speech

### Technical Design

**`transcriber.rs`:**
- Set `params.set_n_threads(...)` and `params.set_beam_size(2)` (or `set_n_best(1)` for greedy)
- Accept an optional `on_segment: impl Fn(String)` callback parameter
- In `new_segment_callback`, call the callback with the new segment text

**`lib.rs`:**
- In `stop_native_recording` command, pass a closure to the transcriber that calls `app_handle.emit("transcription://partial", segment_text)`
- Frontend listens to this event and appends to a `partialText` state

**Frontend:**
- `useRecordingState` hook: listen for `transcription://partial` events while in transcribing state, accumulate into `partialText`
- Display `partialText` in the transcription area (greyed out / italic to indicate in-progress)
- On final `transcription_complete`, replace partial display with final text and trigger paste

### Files to Modify

- `ui/src-tauri/src/transcriber.rs` — set beam_size=2, add segment callback
- `ui/src-tauri/src/lib.rs` — emit `transcription://partial` events from segment callback
- `ui/src/lib/hooks/useRecordingState.ts` — listen for partial events, maintain `partialText`
- `ui/src/App.tsx` or transcription display component — render partial text state

---

## FEAT-008: OTA Auto-Updater

**Priority:** P2
**Type:** Rust + Frontend + CI
**Branch:** `feat/auto-updater`
**Depends on:** —

### Context
Users currently need to manually download a new DMG from GitHub Releases to update. With Tauri's updater plugin, the app checks a `latest.json` endpoint on launch, detects a newer version, and prompts the user to update in-place — no manual download needed after first install.

### Acceptance Criteria
- [ ] App checks for updates on launch via a `latest.json` endpoint
- [ ] User is prompted with version number and release notes when an update is available
- [ ] Update downloads, installs, and relaunches automatically on user confirmation
- [ ] No update prompt when already on latest version
- [ ] Release workflow generates and uploads `latest.json` to GitHub Releases alongside the DMG
- [ ] Update check fails gracefully (no crash or hang) if user is offline

### Technical Design

**`Cargo.toml`:**
- Add `tauri-plugin-updater`

**`tauri.conf.json`:**
```json
"plugins": {
  "updater": {
    "endpoints": ["https://github.com/georgenijo/murmur-app/releases/latest/download/latest.json"],
    "dialog": true
  }
}
```

**`latest.json` (generated by CI):**
```json
{
  "version": "0.3.0",
  "pub_date": "2026-02-19T00:00:00Z",
  "url": "https://github.com/georgenijo/murmur-app/releases/download/v0.3.0/Local.Dictation_0.3.0_aarch64.dmg",
  "signature": "<tauri signature>",
  "notes": "Release notes here"
}
```

**`release.yml` additions:**
- After build, generate `latest.json` using the tag version and DMG URL
- Upload `latest.json` as a release asset alongside the DMG

### Files to Modify
- `ui/src-tauri/Cargo.toml` — add `tauri-plugin-updater`
- `ui/src-tauri/tauri.conf.json` — add updater plugin config
- `ui/src-tauri/src/lib.rs` — register updater plugin
- `.github/workflows/release.yml` — generate and upload `latest.json`

---

## FEAT-009: Homebrew Tap Distribution

**Priority:** P3
**Type:** Infrastructure + CI
**Branch:** `feat/homebrew-tap`
**Depends on:** FEAT-008 (release workflow must be stable first)

### Context
Create a personal Homebrew tap so users can install with:
```bash
brew install --cask georgenijo/tap/local-dictation
```

### Acceptance Criteria
- [ ] New GitHub repo `georgenijo/homebrew-tap` created with `Casks/local-dictation.rb`
- [ ] Cask installs the app, defines uninstall and zap stanzas
- [ ] Release workflow automatically updates the cask file (version + SHA256) after each release
- [ ] README updated with Homebrew install instructions

### Technical Design

**`Casks/local-dictation.rb`:**
```ruby
cask "local-dictation" do
  version "0.2.0"
  sha256 "..."

  url "https://github.com/georgenijo/murmur-app/releases/download/v#{version}/Local.Dictation_#{version}_aarch64.dmg"
  name "Local Dictation"
  desc "Privacy-first voice-to-text for macOS"
  homepage "https://github.com/georgenijo/murmur-app"

  app "Local Dictation.app"

  uninstall quit: "com.localdictation"

  zap trash: [
    "~/Library/Application Support/local-dictation",
    "~/Library/Caches/com.localdictation",
  ]
end
```

**`release.yml` addition:**
- After DMG is built, compute `shasum -a 256` of the DMG
- Use `gh` CLI or direct git push to update `local-dictation.rb` in `georgenijo/homebrew-tap` with new version + SHA256
- Requires a `TAP_GITHUB_TOKEN` secret with write access to the tap repo

### Files to Create/Modify
- New repo: `georgenijo/homebrew-tap/Casks/local-dictation.rb`
- `.github/workflows/release.yml` — add cask update step
- `README.md` — add Homebrew install instructions

---

## FEAT-010: curl One-Line Installer

**Priority:** P3
**Type:** Shell script
**Branch:** `feat/curl-installer`
**Depends on:** —

### Context
A shell script at the repo root that installs the app and optionally downloads a Whisper model. Users run:
```bash
curl -fsSL https://raw.githubusercontent.com/georgenijo/murmur-app/main/install.sh | sh
```

### Acceptance Criteria
- [ ] Script fetches the latest release DMG URL from GitHub API (no hardcoded version)
- [ ] Downloads DMG, mounts it, copies `.app` to `/Applications`, unmounts
- [ ] Prompts user to choose a Whisper model (large-v3-turbo / small.en / base.en / skip)
- [ ] Downloads selected model to `~/Library/Application Support/local-dictation/models/`
- [ ] Shows clear progress for both the app download and model download
- [ ] Handles already-installed case gracefully (asks before overwriting)
- [ ] Works on both Apple Silicon and Intel (detects arch, uses correct DMG)
- [ ] README updated with curl install instructions

### Technical Design

**`install.sh` flow:**
1. Detect arch (`uname -m`) — select `aarch64` or `x86_64` DMG
2. Hit GitHub API: `https://api.github.com/repos/georgenijo/murmur-app/releases/latest`
3. Extract DMG URL from response with `grep`/`sed`
4. Download with `curl` + progress bar
5. `hdiutil attach` to mount, `cp -r` app to `/Applications`, `hdiutil detach`
6. Present model menu, download selected model with `curl`
7. Print success message with next steps

### Files to Create/Modify
- `install.sh` (new) — installer script at repo root
- `README.md` — add curl install instructions

---

## FEAT-011: Custom Vocabulary / Initial Prompt for Whisper

**Priority:** P1
**Type:** Rust + Frontend
**Branch:** `feat/custom-vocabulary`
**Depends on:** —

### Context
Whisper's decoder can be biased toward specific words, spellings, and technical terms via an `initial_prompt` parameter at inference time. The model uses this as contextual priming — it doesn't appear in the output but steers transcription toward those exact spellings when it hears phonetically similar sounds.

Examples of what this fixes:
- "Tori" → "Tauri"
- "clod" / ".clod" → "Claude" / ".claude"
- "R dev" → "rdev"
- "see pal" → "cpal"

The user maintains a custom vocab list in Settings that gets passed to every inference call.

### Acceptance Criteria
- [ ] Settings panel has a "Custom Vocabulary" textarea
- [ ] User can enter a comma-separated or newline-separated list of words/phrases
- [ ] Vocab list persists in localStorage
- [ ] Vocab list is passed as `initial_prompt` to Whisper on every transcription
- [ ] Empty vocab list = no initial prompt (current behaviour preserved)
- [ ] A sensible default list is pre-populated (Tauri, Claude, rdev, cpal, etc.) that the user can edit

### Technical Design

**`transcriber.rs`:**
- `transcribe()` function accepts an optional `initial_prompt: Option<&str>` parameter
- `params.set_initial_prompt(prompt)` called when value is present

**`lib.rs`:**
- `stop_native_recording` Tauri command reads `initial_prompt` from the invocation payload (passed from frontend settings)

**Frontend:**
- `settings.ts` — add `customVocabulary: string` field with a default string of common technical terms
- `SettingsPanel.tsx` — add a textarea under a "Transcription" section, labelled "Custom Vocabulary"
- When `stop_native_recording` is invoked, pass `customVocabulary` from settings as the prompt

**Default vocab suggestion:**
```
Tauri, rdev, cpal, whisper-rs, arboard, Claude, .claude, osascript, localhost, macOS, GitHub, API, JSON, TypeScript, React, Rust
```

### Files to Modify
- `ui/src-tauri/src/transcriber.rs` — add `initial_prompt` param
- `ui/src-tauri/src/lib.rs` — pass prompt from command payload to transcriber
- `ui/src/lib/settings.ts` — add `customVocabulary` field + default
- `ui/src/components/settings/SettingsPanel.tsx` — add vocabulary textarea
